import Image from "next/image"

import { ArticleLayout } from "@/layouts/article-layout"

// import one from "./one.png" // import two from "./two.png"

export const meta = {
  author: "Alex Vyber",
  date: "2023-02-05",
  title: "Creating a Wordle Game in React and TypeScript 2022",
  description:
    "I want to share a small tip regarding the block scope. Specifically when we want to create it on purpose.",
}

export default (props) => <ArticleLayout meta={meta} {...props} />

**Creating a Wordle Game in React and TypeScript**

### Mike Gold

This book is for sale at
[http://leanpub.com/creatingawordlegameinreactandtypescript](http://leanpub.com/creatingawordlegameinreactandtypescript)
This version was published on 2022-11- This is aLeanpubbook. Leanpub empowers authors and publishers with the Lean
Publishing process.Lean Publishingis the act of publishing an in-progress ebook using lightweight tools and many
iterations to get reader feedback, pivot until you have the right book and build traction once you do. © 2022 Mike Gold

**Tweet This Book!** Please help Mike Gold by spreading the word about this book on Twitter! The suggested tweet for
this book is: A fun way to learn React and TypeScript The suggested hashtag for this book is#reactjs #typescript #game
#wordle. Find out what other people are saying about the book by clicking on this link to search for this hashtag on
Twitter: #reactjs #typescript #game #wordle

I dedicate the book to my Wife, Nina, who has assisted me in the editing and creation of this book.

## Contents

- Part One
  - Introduction.
  - Creating a Letter Component.
  - Running the app
  - Styling further with Styled Components
  - Coming up Next
- Part Two.
  - Introduction.
  - The Word Component Design
  - The Unevaluated Case.
  - Inputting the Word.
  - Coming up Next
- Part Three.
  - Introduction.
  - The Wordle Algorithm.
  - Coding the Algorithm
  - Testing the Algorithm
  - Hooking the Evaluation Function to the Board.
  - Coming up Next:
- Part Four.
  - Introduction.
  - Adding the Word Board.
  - Adding Win and Lose Logic.
  - Adding Animation CONTENTS
  - Coming up Next
- Part Five.
  - Introduction.
  - The VirtualKey Component.
  - Creating the Keyboard.
  - Hooking it all up
  - Coloring the Keys based on Accuracy
  - Conclusion
- Appendix
  - Union Types.
  - Interfaces
  - Named functions vs Anonymous Functions.
  - Deconstruction
  - Enums
  - Map Type
  - map function
  - Optional Chaining

## Part One

### Introduction.

My family and I are kind of addicted to this new game called Wordle. Wordle is the MasterMind of words, where you guess
a 5-letter word and the program tells you which letters you guessed right. The program lights up a clue for each letter:
A green letter indicates you got the right letter in the right position, yellow means the right letter in the wrong
position, and a dark grey background means that letter is not used. In this book, we will be showing you how to create
your own Wordle App using the power of React and Typescript. There are a couple of approaches we could take with React
to create this application. We could go the class object-oriented route, or we could go the functional component route.
We are going to do the latter for this article: Setup If you haven’t yet, you’ll need to install nodejs from here. You
will also want to install the latest version of npm and npx globally once you have node installed nodejs. 1 npm install
-g npm 2 npm install -g npx To set up a blank react project with typescript run the following command inside the folder
you will be using for your Wordle Project:

Part One 2 1 npx create-react-app wordle --template typescript This may take a while, so be patient! My favorite React
editor is Visual Studio Code. I recommend downloading this IDE (Integrated Development Environment) to follow this
tutorial. Open the folder in the wordle directory and we are ready to begin. Visual Code IDE

### Creating a Letter Component.

```
Our first step in the project is to create the letter component. The
letter will have 4 states associated with it:
Position: Position of the letter in the word, indicated by a number
Letter: The actual letter of the alphabet, indicated by a string
Accuracy: Background colors Green, Yellow, and Dark Grey, indi-
cated by an enum.
```

Part One 3 First we will create a component directory under our src (source) directory, and then add the new Letter
component directory called Letter. Next create a file index.tsx in the Letter folder. tsx is the extension for
typescript components in React. Letter Component File Next we’ll create the component shell that houses the component.
In a functional component, this is fairly easy.

Part One 4 Letter Component in TypeScript At the top of the component, we pass in the prop values. All the props are
defined on the ILetterProps interface, and then decon- structed when they are passed into our component as shown below.
The props will show up as attributes on the Letter component when it is used in a parent component.
`1 **exportconst** Letter=({position, value, accuracy}:ILette\ 2 rProps)=>{` In React, we render the component in the
return statement using tsx. Tsx looks a lot like html mixed with typescript. For now we are only rendering one of the
states: letterValue. `1 **return** ( 2 <> 3 <button style={{width:'50px', height:'50px'}}> 4 {value}</button> 5 </> 6 )`
We’ve stuck the letterValue in a button, and in order to evaluate the value in React, we put letterValue in curly
brackets}. Later in this

Part One 5 article, we will introduce a React utility called styled components that will make styling the component a
bit easier. Let’s see if we can test the component so far. For that, we will need to rewrite App.tsx, which was
generated under the src directory by the npx command: When you open App.tsx up it currently looks something like this
(from the generated npx create): Original App.tsx We are going to empty it out and just add our component:

Part One 6

````JavaScript
1 **import** React **from** 'react'
2 **import** './App.css'
3 **import** Letter,
4 { AccuracyEnum } **from** './component/Letter';
5
6 **function** App() {
7 **return** (
8 <Letter accuracy={AccuracyEnum.correct}
9 position={ 0 } value='H'/>
10 )
11 }
12
13 **exportdefault** App```

Note that we needed to add an import statement to the top of
the file in order to bring the Letter component and the Accuracy
Enumeration into the App component. In the App component, we
render a single letter with accuracy correct, position 0 and a value
of H.

### Running the app

````

To run our React application, we will bring up a bash terminal window from the Terminal menu item in Visual Studio Code,
and then run the following command: 1 npm run start

```

Part One 7
Running the App
This will bring up a browser window running the application on
localhost port 3000 as shown below:

Part One 8
H in the Browser
Here we can see our component rendering as a button with the
letter H, but there is still more to do before this component looks
like a Wordle letter!

### Styling further with Styled Components

The next thing we want to do is to have the accuracy enumeration
color the button based on the accuracy of the letter position. To
do the styling, we are going to use styled components. You can
install styled components from npm in your bash terminal with the
following command (Make sure that bash is in the Wordle folder
when you do this).

Part One 9
1 npm install –save styled-components
Inside our Letter component folder, we’ll add a new file called
index.style.tsx and in this file we’ll create our styled component
StyledLetter. Here we can use regular old css in between the tick
marks ‘.
1 **import** styled **from** 'styled-components'
2
3 **exportconst** StyledLetterButton=styled.button`4 margin: 2px;
5 width: 50px;
6 height: 50px;
7 border-radius: 2px;
8 color: white;
9 font-size: 30px;
10 font-weight: bold;
11 background: green;
12`
To use the Styled Component, we need to alter our letter component
slightly. In index.tsx we replace the button with the StyledLetter-
Button and use it the same way as we did with the button.
1 **exportconst** Letter=
2 ({position, value, accuracy}:ILetterProps)=>{
3
4 **return** (
5 <StyledLetterButton accuracy={accuracy}>
6 {value}
7 </StyledLetterButton>
8 )
9 }
10
11 **exportdefault** Letter

Part One 10
Remember that you still need to import the styled-component
button with:
1 **import** { StyledLetterButton } **from** "./index.style"
When we look at the updated changes (do: npm run start if it’s not
already running), we see the following on localhost:
Styled H in the Browser
We are now getting a little closer to a Wordle game component.
One nice feature of styled components is that it lets you pass in
parameters, and you can alter the look based on the parameter. We
need to pass in the accuracy value as a property into the styled
component, so we can change the color accordingly (remember
correct is green, wrong position is yellow, and doesNotExist is dark
gray).
Here is how we would accomplish this using styled components:
First let’s create a color Map in index.tsx for our accuracy indicators.
This will allow our styled component to map accuracy to actual

Part One 11
colors:
1 **exportconst** accuracyColorMap=
2 **new** Map<AccuracyEnum, **string** >(
3 [
4 [AccuracyEnum.correct,'#6CA965'],
5 [AccuracyEnum.wrongPosition,'#C8B653'],
6 [AccuracyEnum.None,'black'],
7 [AccuracyEnum.doesNotExist,'#787C7F']
8 ]
9 )
Next, let’s alter the styled component in index.style.tsx to react
to an accuracy property on the LetterStyleButton. We’ll add the
accuracy prop parameter as shown after styled.button. Then we
will use the accuracyColorMap to get the color needed for the
background out of the prop.
1 **import** { AccuracyEnum, accuracyColorMap } **from** '.'
2
3
4 **exportconst** StyledLetterButton=
5 styled.button<{ accuracy: **AccuracyEnum** }>`6 margin: 2px;
7 width: 50px;
8 height: 50px;
9 border-radius: 2px;
10 color: white;
11 font-size: 30px;
12 font-weight: bold;
13 background: **${** props =>
14 accuracyColorMap.get(props.accuracy) **}** ;
15`
Now add the Letter component containing the StyledLetterButton
to App.tsx in order to test:

Part One 12
1 **import** React **from** 'react'
2 **import** logo **from** './logo.svg'
3 **import** './App.css'
4 **import** Letter, { AccuracyEnum } **from** './component/Letter'
5
6 **function** App() {
7 **return** (
8 <div>
9 <Letter accuracy={AccuracyEnum.correct}
10 position={ 0 } value='R'/>
11 <Letter accuracy={AccuracyEnum.doesNotExist}
12 position={ 1 } value='E'/>
13 <Letter accuracy={AccuracyEnum.wrongPosition}
14 position={ 2 } value='A'/>
15 <Letter accuracy={AccuracyEnum.wrongPosition}
16 position={ 3 } value='C'/>
17 <Letter accuracy={AccuracyEnum.correct}
18 position={ 4 } value='T'/>
19 </div>
20 )
21 }
22
23 **exportdefault** App
And wallah! We have created our first Wordle component.

Part One 13
Styled REACT in Browser

### Coming up Next

In our next articles we will create the game logic and components
needed to complete the game. This will include a word component
that aggregates the letters together, an input component to allow
you to enter your guess, a button for entering the guess, and a board
to show your progress so far.

## Part Two.

### Introduction.

React is a powerful tool for developing web applications, but it takes
some time getting used to ‘The React Way of Doing Things’. This
tutorial helps you get started with a real world application. In our
previous article, we discussed how to set up React and create our
letter component for Wordle. In this article we will create our Word
Display Component and Word Input Component.
Let’s start by creating a new component called Word which will
consist of our letter components.
Starting the Word Component

Part Two 15

### The Word Component Design

We want our Word component to take in a string and display it in
terms of Letter Components. If the Word has not been evaluated,
the letters should have black backgrounds; otherwise, they will
have a background that reflects their accuracy once evaluated.
This design infers we should use two props: isWordEvaluated and
guessWordValue.
Let’s start by creating a new component called Word which will
accept the following props:

- isWordEvaluated- to indicate whether the word has been
  scored or not, and
- guessWordValue- a string that represents the word that has
  been guessed.
  Starting the Word Component
  We’ll also reflect these two props as states in the Word Component.
  Here we introduce two React hooks:useStateanduseEffect. us-
  eState allows us to maintain the state of the word’s value and
  also determine whether it is being evaluated or not. useState is

Part Two 16
initialized with an empty value and returns two items in an array:
a readonly state value, and a setter for setting that value. When a
state is set, it forces a rerender of the component. So every time we
call setGuessValue, it will redraw the guessed letters with the new
value in guessValue.
1 **const** [guessValue, setGuessValue]=useState('')
But how do we ensure that the state value updates every time the
prop changes? That’s where useEffect comes into play. useEffect
allows us to synchronize the prop with the state value by setting
the state value every time the prop changes. When guessWordValue
changes, useEffect triggers and sets the state of guessValue. The
useEffect call below consists of two parameters: The first parameter
is the action and the second parameter is an array of trigger values.
If the trigger value changes, it will call the action. In the case shown
below, when the guessWordValue prop changes, it will set the state
of the guessValue state. By setting the state using the setter returned
from useState, it forces a rerender of the Word component with the
new guessValue.
1 useEffect(()=>{
2 setGuessValue(guessWordValue)},
3 [guessWordValue]
4 )
The code below shows the Word component with all the hooks in
place.

Part Two 17
1 **import** { useState } **from** 'react'
2
3 **interface** IWordProps {
4 isWordEvaluated: **boolean**
5 guessWordValue: **string**
6 }
7
8 **exportconst** Word=
9 ({isWordEvaluated, guessWordValue}:IWordProps)=>{
10 **const** [isEvaluated, setIsEvaluated]=useState( **false** )
11 **const** [guessValue, setGuessValue]=useState('')
12
13 useEffect(()=>{
14 setGuessValue(guessWordValue)},
15 [guessWordValue]
16 )
17
18 useEffect(()=>{
19 setIsEvaluated(isWordEvaluated)},
20 [isWordEvaluated]
21 )
22
23 **return** (
24 _// letter rendering goes here_
25 <>
26
27 </>
28 )
29 }
We can now use these state values to determine how to render the
letters. The first step is for the word to use the guessValue, and
produce a letter component for each letter in the string. First we
need to handle the unevaluated case, which just shows black letters.

Part Two 18

### The Unevaluated Case.

To produce a rendered word, we’ll take advantage of the map
function. This is different from the Map we used in the previous
article, which was a dictionary data structure. The map function
allows us to map a collection of states directly to a collection of
rendered components. In this case we will map the letters in a string
to a set of Letter components.
1 **import** { useState } **from** 'react'
2 **import** Letter, { AccuracyEnum } **from** '../Letter'
3
4 **interface** IWordProps {
5 isWordEvaluated: **boolean**
6 guessWordValue: **string**
7 }
8
9 **exportconst** Word=
10 ({isWordEvaluated, guessWordValue}:IWordProps)=>
11 {
12 **const** [isEvaluated, setIsEvaluated]
13 =useState(isWordEvaluated)
14 **const** [guessValue, setGuessValue]
15 =useState(guessWordValue)
16
17 useEffect(()=>{
18 setGuessValue(guessWordValue)},
19 [guessWordValue]
20 )
21
22 useEffect(()=>{
23 setIsEvaluated(isWordEvaluated)},
24 [isWordEvaluated]
25 )
26

Part Two 19
27 **return** (
28 _// letter rendering goes here_
29 <>
30 {
31 guessValue.toUpperCase()
32 .split('')
33 .map( (nextLetter, letterIndex)=>
34 {
35 **return** <Letter
36 key={'letter\_'+letterIndex}
37 value={nextLetter}
38 accuracy={AccuracyEnum.none}
39 position={letterIndex}/>
40 })}
41 </>
42 );
43 }
In the render code, we split up the letters into an array using
the split function. Then we map each letter (and the index of the
letter) to a Letter Component. The value attribute in the Letter
component is set to the next letter in the string, accuracy is set to
AccuracyEnum.none for now (indicating black background), and
position of the letter is set to the index provided by the map
function. Note we also added a key attribute to the tsx mark
up so React can distinguish between each unique element in the
collection. (If we don’t add the key we get a warning from React).
Let’s add our Word to our main App component to test out the
component. We’ll use the unevaluated state of the word and a guess
word of TESTS for now:

Part Two 20
1 **import** React **from** ‘react’
2 **import** ‘./App.css’
3 **import** { Word } **from** ‘./component/Word’
4
5 **function** App() {
6 **return** (
7 <div>
8 <Word isWordEvaluated={ **false** }
9 guessWordValue=’TESTS’/>
10 </div>
11 )
12 }
13
14 **exportdefault** App
When we run npm run start, this code produces the output shown
below in the browser at localhost:3000
Unevaluated Word Guess

Part Two 21

### Inputting the Word.

Let’s take this one step further. Instead of hard-coding the Word
TESTS into the word component, let’s allow the user to enter the
word.
We’ll start by creating a folder called WordEntry under components
and add our index.tsx and index.style.tsx files.
Adding the WordEntry component
Next we’ll create the styled component for our word entry control
in index.style.tsx. The css we used in the styled component gives
us a nice rounded blue bordered entry control. Feel free to change
this to suit your style.
Import styled from ‘styled-components’

Part Two 22
1 **exportconst** StyledWordEntry=styled.input`2 margin: 5px;
3 border-radius: 10px;
4 width: 250px;
5 height: 30px;
6 display: block;
7 border:2px solid blue;
8 &:focus {
9 outline: none;
10 box-shadow: 0px 0px 2px blue;
11 }
12`
Next we’ll create the actual WordEntry Component that uses this
styled input control in index.tsx. There is quite a bit to explain here,
so listen carefully. We need be able to communicate the word typed
into the WordEntry control back to the parent so it can pass it on
to the Word component we created. In order to accomplish that
communication in this app, the parent control (App.tsx) will pass
down a callback function as a prop to the WordEntry component
called onGuessEntered. This will allow us to pass the letters typed
so far into the function onGuessEntered and communicate it back
to the parent (App.tsx) by calling this function.
The handleLetterEntry function is called from the onChanged event
that occurs in an input control every time you make a change to
the input control. The event returned from changing input has the
latest user input assigned to e.target.value located on the event.
handleLetterEntry calls the callback onGuessEntered callback that
propagates to the parent.
Note we also force the guess string in the WordEntry control to be
a valid string in the handleLetterEntry by transforming the value
entered to an alphabetic string and toUpperCase which is bound to
the value attribute in the StyledWordEntry input control. So now,
it doesn’t matter if your shift key is down or not—-the input control
will always show capital letters and will not allow you to type non-

Part Two 23
alphabetic characters.
1 **import** { useState } **from** "react"
2 **import** { StyledWordEntry } **from** "./index.style"
3
4 **interface** IWordEntryProps {
5 onGuessEntered(guess: **string** ): **void**
6 }
7
8 **exportconst** WordEntry=
9 ({onGuessEntered}:IWordEntryProps)=>
10 {
11
12 **const** [value, setValue]=useState('')
13 **const** getValidWordleString =
14 (rawString: **string** )=>{
15
16 **const** upperCaseString= rawString.toUpperCase()
17 **const** validWordleString=
18 rawString.replace(/[^a-z]/gi,'');
19 **return** validWordleString?.toUpperCase()
20 }
21
22 **const** handleLetterEntry=(e: **any** )=>{
23 **const** validString: **string** =
24 getValidWordleString(e.target.value)
25 onGuessEntered(validString);
26 setValue(validString)
27 }
28
29 **return** (
30 <StyledWordEntry autoFocus
31 placeholder='Enter your guess...'value={value}
32 maxLength={ 5 }
33 onChange={(e)=>handleLetterEntry(e)}
34 />

Part Two 24
35 )
36 }
Let’s see what this communication looks like in the parent com-
ponent App.tsx. The callback is an anonymous function (guess)
)setWordGuess(guess) which sets the wordGuess state in the
parent control App.tsx. The WordEntry control makes the call
through the callback function to set its current wordGuess value.
The wordGuess state is passed into the Word control via a prop.
The prop triggers the useEffect hook in the Word control to set
the guessValue state of that control. By setting the guessValue, the
Word is forced to rerender with the new value.
1 **import** React, { useEffect, useState } **from** 'react'
2 **import** './App.css'
3 **import** { Word } **from** './component/Word'
4 **import** { WordEntry } **from** './component/WordEntry'
5
6 **function** App() {
7 **const** [wordGuess, setWordGuess]=useState('')
8
9 **return** (
10 <div>
11 <WordEntry
12 onGuessEntered={
13 (guess)=>setWordGuess(guess)}
14 />
15 <Word
16 isWordEvaluated={ **false** }
17 guessWordValue={wordGuess}
18 />
19 </div>
20 )
21 }
22
23 **exportdefault** App

Part Two 25
Let’s run the app and see what happens (npm run start):
Adding the WordEntry component
As we type the letters or change any of the letters in the text box,
the string updates in the Wordle puzzle.

### Coming up Next

In the next part of the series, we’ll actually apply game logic to our
guess. Stay tuned!

## Part Three.

### Introduction.

Sometimes the best way to learn a skill is by doing a fun exercise.
In this series, you will learn several aspects of ReactJS through
creating a Wordle game. Last time we covered how to create a
Word Entry control and integrate the control with the Wordle
guess. In this article we are going to cover how to use ReactJS
to evaluate Wordle guess, and how to test the algorithm involved
in that evaluation using Jester. Finally, we’ll hook it all up to an
evaluation button that will let us know how close we came to our
first guess.

### The Wordle Algorithm.

```

There are probably several ways we could conquer scoring a word in Wordle, but the approach taken here involves the
following algorithm.

```

1. Initialize a results array of five accuracy values to all be does-
   notexist. Initialize an empty array called markedCorrect. Also
   initialize a mask string to the same value as the answer.
2. Loop through the letters you guessed and see which ones match
   in the same position as the mask. Mark an array of results in the
   same index positions as being correct. Replace all correct indices
   in the mask string with an underscore. For any indices found
   matching in the exact position as the mask, add those indices to
   the markedCorrect array.
3. Loop through the letters you guessed and see which ones are
   included in the mask somewhere, but whose index is not included

```

Part Three 27 in the markedCorrect. If the guess letter is found in the mask, mark the array of results at the same
index location as the guess position indicating that it is in the wrong position. Each time you find a letter from your
guess in the mask, replace that letter’s index position with an underscore in the mask so it won’t find it again.

````

### Coding the Algorithm

If we follow the instructions above carefully, the algorithm will be
an easy translation to javascript.

### Step #1

Initialize an array of five accuracy values to all be doesnotexist.
Also initialize a mask string to the same value as the answer.
1 **let** result=[AccuracyEnum.doesNotExist,
2 AccuracyEnum.doesNotExist,
3 AccuracyEnum.doesNotExist,
4 AccuracyEnum.doesNotExist,
5 AccuracyEnum.doesNotExist]
6
7 **let** mask=answer
8
9 **let** markedCorrect: **number** []=[]
**Step #2**
Loop through the letters you guessed and see which ones match
in the same position as the mask. Mark an array of results in the
same index positions as being correct. Replace all correct indices in
the mask string with an underscore. Finally, record the indices that
were marked correct so we don’t evaluate them again in our guess.
Note: we needed to create areplaceAtfunction in order to replace
characters at an index in the mask.

Part Three 28
1 guess.split('').forEach((guessLetter, index)=>{
2 **if** (guessLetter===mask[index] ) {
3 result[index]=AccuracyEnum.correct
4 mask=replaceAt(mask, index,'\_')
5 markedCorrect.push(index)
6 }
7 })
8
9 **const** replaceAt=(source: **string** , index: **number** ,
10 replacement: **string** ): **string** =>
11 {
12 **if** (index>=source.length) {
13 **return** source.valueOf()
14 }
15
16 **return** source.substring( 0 , index)+
17 replacement+source.substring(index+ 1 )
18 }
**Step #3**
Loop through the letters you guessed but haven’t already been
marked correct and see which ones are included in the mask
somewhere. If the guess letter is found in the mask, mark the array
of results in the same index as the guess position with the wrong
position flag. Each time you find a letter from your guess in the
mask, replace that letter’s index position with an underscore in the
mask so it won’t rediscover it.

Part Three 29

```JavaScript

1 guess.split('').forEach((guessLetter, index)=>{
2
3 **if** (!markedCorrect.includes(index)&&
4 mask.split('').includes(guessLetter)) {
5 result[index]=AccuracyEnum.wrongPosition
6 **const** firstPositionInAnswer=
7 mask.indexOf(guessLetter)
8 mask=replaceAt(mask,
9 firstPositionInAnswer,'\_')
10 }
11 })



```

### Testing the Algorithm

One easy way to test the algorithm is to use React’s built in test
framework called Jester. When you created your app, it would
have automatically set up Jester. The only thing you need to do
is create a tests folder and add a test file to it. The test file should be
named something like <react component name>.test.ts. In our case
we named our test file evaluation.test.ts.
The React test command will recognize the test file from the test.ts
extension automatically. Let’s create our first test on the algorithm
code: a simple correct word match test which evaluates the guess
‘react’ against the answer ‘react’.

```

Part Three 30
1 test('evaluate wordle all correct', ()=>{
2 **const** result=evaluateWordScore('react','react')
3 expect(result[ 0 ]).toBe(AccuracyEnum.correct)
4 expect(result[ 1 ]).toBe(AccuracyEnum.correct)
5 expect(result[ 2 ]).toBe(AccuracyEnum.correct)
6 expect(result[ 3 ]).toBe(AccuracyEnum.correct)
7 expect(result[ 4 ]).toBe(AccuracyEnum.correct)
8 })
The unit test function takes a title as the first parameter and
a test function as the second parameter. The function acts on
the evaluateWordScore function we are testing that contains the
Wordle algorithm. When the function returns, we compare the
result to what we expect it to be. If all expects match, the test passes.
Here are some more tests to evaluate more permutations of guesses:
1 test('evaluate wordle all incorrect', ()=>{
2 **const** result=evaluateWordScore('react','mound')
3 expect(result[ 0 ]).toBe(AccuracyEnum.doesNotExist)
4 expect(result[ 1 ]).toBe(AccuracyEnum.doesNotExist)
5 expect(result[ 2 ]).toBe(AccuracyEnum.doesNotExist)
6 expect(result[ 3 ]).toBe(AccuracyEnum.doesNotExist)
7 expect(result[ 4 ]).toBe(AccuracyEnum.doesNotExist)
8 })
9
10 test('evaluate wordle wrong position', ()=>{
11 **const** result=evaluateWordScore('react','house')
12 expect(result[ 0 ]).toBe(AccuracyEnum.doesNotExist)
13 expect(result[ 1 ]).toBe(AccuracyEnum.wrongPosition)
14 expect(result[ 2 ]).toBe(AccuracyEnum.doesNotExist)
15 expect(result[ 3 ]).toBe(AccuracyEnum.doesNotExist)
16 expect(result[ 4 ]).toBe(AccuracyEnum.doesNotExist)
17 })
18
19 test('evaluate one letter in right position,

Part Three 31
20 one in wrong position', ()=>{
21 **const** result=evaluateWordScore('oboes','moons')
22 expect(result[ 0 ]).toBe(AccuracyEnum.wrongPosition)
23 expect(result[ 1 ]).toBe(AccuracyEnum.doesNotExist)
24 expect(result[ 2 ]).toBe(AccuracyEnum.correct)
25 expect(result[ 3 ]).toBe(AccuracyEnum.doesNotExist)
26 expect(result[ 4 ]).toBe(AccuracyEnum.correct)
27 })
28
29 test('evaluate one letter in right position,\
30 with two of the same letter in the guess,\
31 and one in wrong position', ()=>{
32 **const** result=evaluateWordScore('roomy','tombs')
33 expect(result[ 0 ]).toBe(AccuracyEnum.doesNotExist)
34 expect(result[ 1 ]).toBe(AccuracyEnum.correct)
35 expect(result[ 2 ]).toBe(AccuracyEnum.doesNotExist)
36 expect(result[ 3 ]).toBe(AccuracyEnum.wrongPosition)
37 expect(result[ 4 ]).toBe(AccuracyEnum.doesNotExist)
38 })
39
40 test('evaluate word with 1 letter in the wrong place and\
41 also the right place', ()=>{
42 **const** result=evaluateWordScore('taste','papal')
43 expect(result[ 0 ]).toBe(AccuracyEnum.doesNotExist)
44 expect(result[ 1 ]).toBe(AccuracyEnum.correct)
45 expect(result[ 2 ]).toBe(AccuracyEnum.doesNotExist)
46 expect(result[ 3 ]).toBe(AccuracyEnum.doesNotExist)
47 expect(result[ 4 ]).toBe(AccuracyEnum.doesNotExist)
48 })
To run the tests, type
1 npm run test
This will run all the tests in your test folder. The results of our tests
are shown below:

```

Part Three 32
Test Results

```

### Hooking the Evaluation Function to the Board.

Well the hard part is done: we have created a function that can take
a Wordle guess and compare it against the answer. But how do we
implement this in our application? The first step is to find a place to
call the function. If we go into the Word component, this is as good
a place as any. When the word is marked as having been evaluated,
we will want to check the answer. useEffect would be perfect for
handling this in the Word component.
Currently our useEffect for evaluation looks like this:
1 useEffect(()=>{
2 setIsEvaluated(isWordEvaluated)
3 }, [isWordEvaluated])
We want to not only mark the isEvaluated flag, but also take the
opportunity to get the word scoring in this hook.
First we’ll create a new state to save our evaluated results:

Part Three 33
1 **const** inititalAccuracyArray=
2 [AccuracyEnum.none,
3 AccuracyEnum.none,
4 AccuracyEnum.none,
5 AccuracyEnum.none,
6 AccuracyEnum.none]
7
8 **const** [evaluatedResults, setEvaluatedResults]=
9 useState<AccuracyEnum[]>(inititalAccuracyArray)
Then we’ll call the word evaluation in our isWordEvaluated useEf-
fect hook, and put the results from the scoring into the evaluate-
dResults state.
1 useEffect(()=>{
2
3 **const** results=
4 evaluateWordScore(guessValue,
5 retrieveAnswer().toUpperCase())
6 setEvaluatedResults(results)
7 setIsEvaluated(isWordEvaluated)
8 }, [isWordEvaluated])
We also export a stubbed retrieveAnswer function inside a type-
script file that just returns a static answer string. In the future,
the retrieveAnswer function can fetch the word from a list. Under
utilities we create answerRetriever.ts and add the following code.
`export const retrieveAnswer = (): string)`

But how does this relate to showing the user their different color
results? Well, when we set the evaluatedResults state, it will trigger
a render. We just need to utilize the scoring results in our rendering
of the Word:

Part Three 34
1 **return** (
2 _// letter rendering goes here_
3 <div style={{ marginLeft:'15px'}}>
4 {
5 guessValue.toUpperCase().split('')
6 .map( (nextLetter, letterIndex)=>{
7 **return** <Letter
8 key={'letter\_'+letterIndex}
9 value ={nextLetter}
10 accuracy={isEvaluated?
11 evaluatedResults[letterIndex]:
12 AccuracyEnum.none}
13 position={letterIndex}/>
14 })}
15 </div>
16 );
By grabbing the evaluatedResults for each letter index, the Letter
component will convert the accuracy prop into a background color
based on the accuracy value. Note that we check to see if the
accuracy was evaluated, otherwise we set the accuracy to none:
1 accuracy={isEvaluated?
2 evaluatedResults[letterIndex]:
3 AccuracyEnum.none}
How do we know when to evaluate the guess? What we’ll do is add
a button next to the guess input inside the WordEntry component
to trigger an evaluation. When the button is clicked, the button will
call onGuessComplete to force an evaluation on the word.

Part Three 35
1 <StyledWordEntryContainer>
2 <StyledWordEntry autoFocus
3 placeholder='Enter your guess...'
4 value={value}
5 maxLength={ 5 }
6 onChange={(e)=>handleLetterEntry(e)}
7 />
8 <StyledEvaluateButton onClick={onGuessComplete}>
9 Guess
10 </StyledEvaluateButton>
11 </StyledWordEntryContainer>
The button is a styled component, so we can dress it up a bit and
align it with the input control, as well:
1 **exportconst** StyledEvaluateButton=styled.button`2 width: 72px;
3 height: 40px;
4 background: #CC4433;
5 color: white;
6 border-radius: 5px;
7 margin: 15px;
8 position: relative;
9 top: 10px
10`
Also, we probably want to hide the button until all 5 letters are
typed into the guess. We can hide the button with a conditional
statement that never shows the component if the guess value is not
5 letters long:

Part Three 36
1 **return** (
2 <StyledWordEntryContainer>
3 <StyledWordEntry autoFocus
4 placeholder='Enter your guess...'value={value}
5 maxLength={ 5 }
6 onChange={(e)=>handleLetterEntry(e)}
7 />
8 { (value.length!== 5 )?'':
9 <StyledEvaluateButton onClick={onGuessComplete}>
10 Guess
11 </StyledEvaluateButton>
12 }
13 </StyledWordEntryContainer>
14 )
Now let’s run this test against the word ‘react’ as our answer and
guess slate:
Prior to evaluation, the application looks like this:

Part Three 37
Test Results
When we hit the Guess button, it looks like this:

Part Three 38
Test Results
What if we do not want to click the Guess Button with the mouse?
What if we just want to use the Enter Key to trigger a guess? To
allow for an Enter key press, we need to implement the onKeyPress
event inside the StyledWordEntry input control:
1 <StyledWordEntry autoFocus
2 placeholder='Enter your guess...'
3 value={value}
4 maxLength={ 5 }
5 onChange={(e)=>handleLetterEntry(e)}
6 onKeyPress={e=>handleEnterPressed(e)} />
handleEnteredPressed should simply call onGuessComplete if the
enter key is pressed.

Part Three 39
1 **const** handleEnterPressed=
2 (e: **React.KeyboardEvent** <HTMLInputElement>)=>
3 {
4 **if** (e.key==="Enter") {
5 onGuessComplete()
6 }
7 }
Okay, so we have handled both enter and mouse click, but another
behavior we may want for our game is to gain focus back to the
input box after we’ve completed a guess. In order to accomplish
this functionality, we are going to introduce a new hook called
useRef that is built into React. useRef allows us to get access to
a tsx element through the ref attribute and perform standard built
in functions on the html element they represent. First, let’s declare
a new useRef hook and assign it to variable wordEntryRef.
1 **const** wordEntryRef=useRef<HTMLInputElement>( **null** );
Next, we will use the useRef hook to force focus on the StyledWor-
dEntry control after the word guess is completed:
1 **const** handleGuessComplete=()=>{
2 _// clear and set focus to word entry_
3 setValue('')
4 wordEntryRef?.current?.focus()
5 onGuessComplete()
6 }
Finally, the ref needs to be added to the HTML Element we are
giving focus to, which in this case is the StyledWordEntry:

Part Three 40
1 <StyledWordEntry autoFocus
2 placeholder='Enter your guess...'
3 value={value}
4 maxLength={ 5 }
5 onChange={(e)=>handleLetterEntry(e)}
6 ref={wordEntryRef}
7 onKeyPress={e=>handleEnterPressed(e)} />

### Coming up Next:

```

In this article we learned about how to implement the Wordle
algorithm and wrote some tests to evaluate different word cases
that the algorithm would come across. We also showed how to hook
up the algorithm to the Wordle Word to show a result. In the next
article we’ll hook up the rest of the game including the Wordle
Board and winning and losing logic.

```

## Part Four.

### Introduction.

When you learn React, you really have to immerse yourself into
the framework concepts. Those concepts revolve around your Re-
act components, hooks, states, and third-party components. Also,
when you are programming in the functional world, you need to
keep immutability in mind. Immutability is the idea that you never
mutate (or change) an existing object, you simply create a copy
of that object with the changes in it. We’ll see some examples of
immutability in this article.
In Part III of this article, we showed how to evaluate a word in
Wordle with the Wordle scoring algorithm and display that word
on the page. In previous articles, we implemented the ability for
the user to enter the word. In this article we will show you how to
create a game board containing the Word components.

### Adding the Word Board.

```

Here we’ll add a new component called WordBoard which takes
2 props, the word guessed so far, and the position of the guess in
the array. The WordBoard will house all 6 possible guesses. We’ll
accomplish this by creating an array of guesses and mapping each
guess to a word component with the map function. We’ll also add
all these guesses to a wordGuesses State, which we can use to track
all current guesses. Each guess in the wordGuesses array contains
a guess value and a flag indicating if it has been evaluated or not.
The evaluated flag will signal the render engine whether it should

```

Part Four 42
color the letter with the Wordle score value or treat it as an active
unscored guess.
1 **interface** IGuess {
2 guessedWord: **string** ,
3 evaluated: **boolean**
4 }
5
6 **exportconst** WordBoard=({guess, currentPosition}:
7 IWordBoardProps) =>
8 {
9
10 **const** initialGuessState : **IGuess** []=
11 [
12 { guessedWord:'', evaluated: **false** },
13 { guessedWord:'', evaluated: **false** },
14 { guessedWord:'', evaluated: **false** },
15 { guessedWord:'', evaluated: **false** },
16 { guessedWord:'', evaluated: **false** },
17 { guessedWord:'', evaluated: **false** }
18 ]
19
20 **const** [wordGuesses, setWordGuesses]=
21 useState<IGuess[]>(initialGuessState)
22
23 **return** (
24 <>
25 {
26 wordGuesses.map((wordGuess: **IGuess** ,
27 index: **number** )=>{
28 **return**
29 <Word key={`guesses_ **${** index **}** `}
30 isWordEvaluated={wordGuess.evaluated}
31 guessWordValue={wordGuess.guessedWord\
32 }
33 />

Part Four 43
34 })
35 }
36 </>
37 )
38 }
In order to know which Word Guess we are working on, we need to
track the current word guess position. We’ll do that with a position
state called currentWordIndex:
1 **const** [currentWordIndex, setCurrentWordIndex]=
2 useState( 0 )
When the guess prop changes (the letters guessed so far), we need to
update the guess word array to reflect those changes. We’ll trigger
on the guess prop that was passed into the WordBoard component
inside a useEffect and update the word guess array appropriately.
Note that we set the property evaluated in the guess to false, so it
doesn’t evaluate the guess while the player is still entering it:
1 useEffect(()=>{
2 **if** (currentWordIndex> 5 ) **return**
3 **const** currentGuess: **IGuess** =
4 {
5 guessedWord: **guess** ,
6 evaluated: **false**
7 }
8 **const** updatedGuesses: **IGuess** []=
9 [ ...wordGuesses.slice( 0 , currentWordIndex),
10 currentGuess,
11 ...wordGuesses.slice(currentWordIndex+ 1 )]
12 setWordGuesses(updatedGuesses)
13 }, [guess])
Remember we talked about immutability? In this useEffect hook,
we don’t just replace the current guess into the array. We recreate

Part Four 44
the array with the new guess inside of it! Then we assign the new
array to the wordGuessesState. This is the React way of doing
things. Admittedly it takes some getting used to if you are used
to mutating all your objects.
We also need to react to when the user presses the guess button so
that the guess row gets evaluated by the algorithm. In App.tsx, we
do this by changing the currentPosition after the button is pressed
to the next guess row.
1 **const** handleGuessCompletion=(guess: **string** ): **void** =>{
2 _// check to see if we won_
3
4 setNextGuessPosition(nextGuessPosition+ 1 )
5 }
Then we can add a useEffect to the WordBoard component to detect
this change in the currentPosition prop on the WordBoard:
1 useEffect(()=>
2 {
3 _// check if too many guesses_
4 **if** (currentWordIndex> 5 ) **return**
5 _// check if guess is not finished_
6 **if** (guess.length< 5 ) **return**
7
8 **const** currentGuess: **IGuess** =
9 {guessedWord: **guess** ,
10 evaluated: **true** }
11 **const** updatedGuesses: **IGuess** []=
12 [...wordGuesses.slice( 0 , currentWordIndex),
13 currentGuess,
14 ...wordGuesses.slice(currentWordIndex+ 1 )]
15 console.log('updating guesses...')
16 setWordGuesses(updatedGuesses)
17 setCurrentWordIndex(currentPosition)

Part Four 45
18 }
19 , [currentPosition])
Here we do something very similar to the previous useEffect. We
recreate the wordGuesses array when the currentPosition prop
changes. The difference here is that the guess we insert into the
wordGuesses array has evaluated set to true. By setting evaluated
to true, when the WordBoard renders, it will force the evaluation
of the new guess.

### Adding Win and Lose Logic.

```

In Wordle, if the player guesses all letters correctly within 6 guesses,
they win. If the player has not guessed the word in 6 guesses, the
player loses. The fewer guesses to win, the better.
Based on this requirement, we’ll add our win/lose logic to the
App.tsx component and add three more states to help us implement
it:
1 const [winning, setWinning]
2 =useState< boolean | null >( null )
3 const [gameOver, setGameOver]
4 =useState( false )
5 const [gameOverText, setGameOverText]=useState('')
The winning state will be set when we determine if we won or lost.
We initially set winning to null so it does not trigger on either true
or false until the winning state is purposely set.
First let’s check for a win. We’ll determine if we won the game in
the event handler that triggers on guess completion (when hitting
enter or the guess button). Inside of handleGuessCompletion we’ll
just add some logic to compare the answer to the word guessed by
the user. If the two are equal, we simply need to set the winning
state.

```

Part Four 46
1 **const const** handleGuessCompletion=
2 (guess: **string** ): **void** =>{
3 _// check to see if we won_
4 **if** (wordGuess===retrieveAnswer().toUpperCase()) {
5 setWinning( **true** )
6 **return**
7 }
8
9 setNextGuessPosition(nextGuessPosition+ 1 )
10 }
Now we can use the useEffect hook to trigger on the winning state
and take the appropriate action which is to set the game over state
and fill in the appropriate game over text (‘You Won!!’):
1 useEffect(()=>{
2
3 **if** (winning!= **null** ) {
4 _// force it to evaluate the current word_
5 setNextGuessPosition( 0 )
6 _// game has ended, set this state_
7 setGameOver( **true** )
8 }
9
10 **if** (winning) {
11 setGameOverText('You Won!!')
12 }
13 }, [winning])
Handling losing is similar, except we trigger a loss off of the word
position in a useEffect when we realize we’ve gone beyond the
allotted 6 guesses:

Part Four 47
1 useEffect (()=>{
2 **if** (nextGuessPosition=== 6 ) {
3 setWinning( **false** )
4 }
5 }, [nextGuessPosition])
Now we’ll add to our win/lose useEffect the actions we will take
after a loss.
1 useEffect(()=>{
2 _// if winning is not null then we either won or lost_
3 **if** (winning!= **null** ) {
4 _// force it to evaluate the current word_
5 setNextGuessPosition( 0 )
6 setGameOver( **true** )
7 }
8
9 **if** (winning) {
10 setGameOverText('You Won!!')
11 }
12 **elseif** (winning=== **false** ) {
13 _// game is over, post the answer_
14 setGameOverText(
15 `Word: **${** retrieveAnswer().toUpperCase() **}** `)
16 }
17 }, [winning])
In the case of a loss (when the winning state is set to false), we
set the game over text to the final answer. Since we didn’t get the
answer, we’ll want to let the player know what the actual answer
is by displaying it at the top.
Below is the final rendering in App.tsx:

Part Four 48
1 **return** (
2 <div className='App-board'>
3 { gameOver?
4 <StyledGameOverDisplay>{gameOverText}
5 </StyledGameOverDisplay>
6 :
7 <WordEntry
8 onGuessEntered={(guess)=>setWordGuess(guess)}
9 onGuessComplete={
10 ()=>handleGuessCompletion(wordGuess)}
11 />
12 }
13 <WordBoard guess={wordGuess}
14 currentPosition={nextGuessPosition} />
15 </div>
16 )
If the gameOver state is set to false, it will show the WordEntry
component used to enter the word during the game. Otherwise,
if the game has ended with the gameOver state set to true, it
will ignore the WordEntry component and show the Game Over
Display Information instead inside the StyledGameOverDisplay
component. The game over display styled component looks like
this:
1 **exportconst** StyledGameOverDisplay=styled.div`2 width: 250px;
3 height: 40px;
4 text-align: center;
5 color: white;
6 font-size: 25px;
7`
You can see the final game over state in the figure below.You
Won!!Is styled with the StyledGameOverDisplay with centered
white text.

```

Part Four 49
Final Game

```

### Adding Animation

We can make the Game Over state a little more interesting by
adding animation to our StyledGameOverDisplay styled compo-
nent. Why don’t we make the You Won!! text slowly fade into the
top of the screen. To accomplish this, we’ll add animation styles to
the styled-component that alters the opacity of the text. We’ll start
by defining some key frames that show what opacity value occurs
at each stage of the animation from 0% to 100%.

Part Four 50
1 **const** fadeInAnimation =keyframes`2 0% { opacity: 0}
3 30% { opacity: 0.3 }
4 40% { opacity: 0.6; }
5 100% { opacity: 1; }
6`
Then we’ll animate the styled-component itself for 3 seconds and
just perform the animation once.
1 **exportconst** StyledGameOverDisplay=styled.div`2 width: 250px;
3 height: 40px;
4 text-align: center;
5 color: white;
6 font-size: 25px;
7 animation-name: **${** fadeInAnimation **}** ;
8 animation-duration: 3s;
9 animation-iteration-count: 1;
10`
That’s all there is to it! There are a host of things you can animate in
the css of the styled component including font size, position, color
and more.
Adding all Possible Wordle Words
It’s kind of boring playing Wordle with only one word so we’ll want
to alter our retrieveAnswer module shown below;
1 **exportconst** retrieveAnswer=(): **string** =>
2 { **return** 'choir'}
The easiest way to include all possible Wordle answers in our
project is just to create a new typescript module that declares all
possible words as a javascript array. So we’ll create a new file
wordlelist.ts and put all possible 5-letter acceptable answers here:

Part Four 51
1 **const** wordlelist=[
2 'aback',
3 'abase',
4 'abate',
5 'abbey',
6 'abbot',
7 ...
8 }
9
10 **exportconst** getwordlist=( ): **string** []=>{
11
12 **return** wordlelist
13 }
Now we just need to grab a random word in that list and use it as
our answer for the current puzzle. We’ll alter answerRetriever.ts to
get a random word in the full list contained in wordlelist.ts:
1 **import** { getwordlist } **from** "./wordlelist";
2
3 **exportlet** answer=''
4
5 **exportconst** retrieveAnswer=(): **string** =>{
6
7 **if** (answer.length> 0 ) **return** answer
8
9 **const** wordlelist=getwordlist()
10 _// find a random word in the entire list_
11 _// and return it as the answer_
12 answer=
13 wordlelist
14 [
15 Math.floor(
16 Math.random()*wordlelist.length)
17 ];

Part Four 52
18 **return** answer
19 }

### Coming up Next

```

In this chapter we created the game board and added win/lose logic.
We also handled game over rendering and showed you how to
animate the game over text. Finally, we showed you how to retrieve
a new random answer from a list of 5-letter words for each round
of Wordle. In the next chapter we’ll show you how to replace the
input text for entering the players guess to a fully functional virtual
keyboard.

```

## Part Five.

### Introduction.

```

So far we have entered letters into the game via an input from the
computer keyboard. In this chapter we’ll create a virtual keyboard
that you can use to enter your guess. The keyboard will also serve
the dual purpose of displaying which letters were already guessed
and the accuracy of that letter.

```

### The VirtualKey Component.

We’ll start by creating the VirtualKey component. Note that the key
will behave a lot like the letter component, but it will also allow
you to click it in order to enter a guess. First we’ll create the new
component with a index.tsx file for behavior and a index.style.tsx
filed for a styled component.
Adding the VirtualKey component
Now we will fill in the VirtualKey code. Note that its almost
identical to the Letter component except there is no position state
necessary and also we needed to add onClick behavior to propogate

Part Five 54
to the parent to let it know which letter was clicked. The tsx is
surrounded by a similar styled component to the one used by
theLettercomponent calledStyledVirtualKeyButton. This styled-
component will be used to color the key according to the keys
accuracy in the guesses made so far.
1 **import** { useEffect, useState } **from** "react"
2 **import** { AccuracyEnum } **from**
3 "../../utilities/accuracy.utils"
4 **import** { StyledVirtualKeyButton } **from** "./index.style"
5
6 **exportinterface** IVirtualKeyProps {
7 value: **string**
8 accuracy: **AccuracyEnum**
9 onClickedKey:(key: **string** )=>{}
10 }
11
12 **exportconst** VirtualKey=
13 ({value, accuracy, onClickedKey}:IVirtualKeyProps)=>
14 {
15 **const** [letterValue, setLetterValue]
16 =useState('')
17 **const** [letterAccuracy, setLetterAccuracy]
18 =useState(AccuracyEnum.none)
19
20 useEffect(()=>{
21 setLetterValue(value)
22 }, [value])
23
24
25 useEffect(()=>{
26 setLetterAccuracy(accuracy)
27 }, [accuracy])
28
29
30

Part Five 55
31 **return** (
32 <StyledVirtualKeyButton accuracy={letterAccuracy}
33 onClick={()=>onClickedKey(letterValue)}>
34 {letterValue}
35 </StyledVirtualKeyButton>
36 )
37 }
38
39 **exportdefault** VirtualKey
As mentioned, the styled componentStyledVirtualKeyButtonal-
lows us to style the key according to its current accuracy. The Key
looks slightly different than the letter component, such as having a
larger width and height to make it easier to press. We also need to
map the foreground as the foreground changes based on accuracy
as well. We’ve added a hover state so the user can tell which virtual
key they are about to click. The hover state simply thickens the
border around the virtual key.
1 **import** styled **from** 'styled-components'
2 **import** { AccuracyEnum, accuracyKeyColorMap,
3 accuracyKeyForegroundColorMap } **from**
4 '../../utilities/accuracy.utils'
5
6 **exportconst** StyledVirtualKeyButton=
7 styled.button<{ accuracy: **AccuracyEnum** }>`
8 margin: 2px;
9 height: 90px;
10 min-width: 80px;
11 padding-left: 10px;
12 padding-right: 10px;
13 color: **${** props=>
14 accuracyKeyForegroundColorMap.get(props.accuracy) **}** ;
15 font-size: 30px;
16 font-weight: bold;

Part Five 56
17 border-radius: 10px;
18 border: 2px solid #787C7F;
19 background: **${** props =>
20 accuracyKeyColorMap.get(props.accuracy) **}** ;
21
22 &:hover {
23 border: 5px solid #787C7F;
24 }
25 `

### Creating the Keyboard.

```

TheVirtualKeyboardcomponent will contain all the virtual keys
we need to allow for user input including enter. We can divide the
keyboard into 3 rows, each row containing a set of keys seen on
a standard keyboard. We’ll also add the enter and backspace key
to the last row in order to allow the user to back out a change or
submit their guess. When all is said and done our keyboard will
look like the diagram shown below:

```

Part Five 57
Adding the Keyboard component
The keyboard component consists of three arrays, one for each
keyboard row. The arrays contains either a string of the individual
letter(e.g. ‘A’) or a function of the key(e.g. BackSpace and Enter).
We will use each of the arrays of these strings to map a rendered
row of virtual keys and display it in the browser. Here is the code
for the keyboard component. Note that we are not yet handling
accuracy indication for each key. We will go through coloring of
the keys according to accuracy later in the chapter. For now we
just set the accuracy in the virtual key toAccuracyEnum.none
Note that each Virtual Key child component in the VirtualKeyboard
takes the onClickedKey callback passed in through a prop from the
parent. The onClickedKey is called when the key is pressed and it
will propogate the letter pressed back to the parent (App.tsx) so it
can use it to populate the word guess.

Part Five 58
1 **import** { useState } **from** "react"
2 **import** { AccuracyEnum }
3 **from** "../../utilities/accuracy.utils"
4 **import** VirtualKey **from** "../VirtualKey"
5 **import** { StyledKeyboardRow, StyleKeyboardContainer }
6 **from** "./index.style"
7
8
9 **exportinterface** IVirtualKeyboardProps {
10 onClickedKey(key: **string** ): **void**
11 }
12
13 **exportconst** VirtualKeyboard=
14 ({onClickedKey}:IVirtualKeyboardProps)=>{
15
16
17 **const** InitialFirstRow: **string** []=[
18 'Q',
19 'W',
20 'E',
21 'R',
22 'T',
23 'Y',
24 'U',
25 'I',
26 'O',
27 'P',
28 ]
29
30 **const** InitialSecondRow: **string** []=[
31 'A',
32 'S',
33 'D',
34 'F',
35 'G',

Part Five 59
36 'H',
37 'J',
38 'K',
39 'L',
40 ]
41
42 **const** InitialThirdRow: **string** []=[
43 'BackSpace',
44 'Z',
45 'X',
46 'C',
47 'V',
48 'B',
49 'N',
50 'M',
51 'Enter',
52 ]
53
54 **const** [firstRow, setFirstRow]=
55 useState<IVirtualKey[]>(InitialFirstRow)
56 **const** [secondRow, setSecondRow]=
57 useState<IVirtualKey[]>(InitialSecondRow)
58 **const** [thirdRow, setThirdRow]=
59 useState<IVirtualKey[]>(InitialThirdRow)
60
61 **return** (
62
63 <StyleKeyboardContainer>
64 <StyledKeyboardRow>
65 {firstRow.map(virtualkey=>{
66 **return** (
67 <VirtualKey
68 value={virtualkey}
69 accuracy={AccuracyEnum.none}
70 onClickedKey={onClickedKey}>

Part Five 60
71 </VirtualKey>)})}
72 </StyledKeyboardRow>
73 <StyledKeyboardRow>
74 {secondRow.map(virtualkey=>{
75 **return** (
76 <VirtualKey
77 value={virtualkey}
78 accuracy={AccuracyEnum.none}
79 onClickedKey={onClickedKey}>
80 </VirtualKey>)})}
81 </StyledKeyboardRow>
82 <StyledKeyboardRow>
83 {thirdRow.map(virtualkey=>{
84 **return** (
85 <VirtualKey
86 value={virtualkey}
87 accuracy={AccuracyEnum.none}
88 onClickedKey={onClickedKey}>
89 </VirtualKey>)})}
90 </StyledKeyboardRow>
91 </StyleKeyboardContainer>
92 )
93
94 }
In the code we have a state for each row of letters (e.g. firstRow,
secondRow, thirdRow) that were initialized by constants and these
are mapped to the rendered VirtualKey components. As far as
styling the keyboard is concerned, we use theStyleKeyboardCon-
tainerstyled-component for the overall keyboard and we use the
StyledKeyboardRowstyled-component to style a particular row.
The row styling is mostly about alignment of the keyboard and the
rows of keys within the keyboard. We want to center each row of
keys within the App component. Thejustify-contentflex attribute
allows us to center the rows of the keyboard within the keyboard

Part Five 61
container.
1 **import** styled **from** "styled-components";
2
3 **exportconst** StyleKeyboardContainer=styled.div`4
5 display: flex;
6 flex-direction: row;
7 flex-wrap: wrap;
8 justify-content: center;
9`
10
11 **exportconst** StyledKeyboardRow=styled.div`12 flex-direction: row;
13`

### Hooking it all up

```

Once we have the keyboard created, its time to react to it in the
parent Application. We need to be able to handle the different
virtual key presses propogated to the parent in theonClickedKey
prop. We perform three different actions from this propogated
callback depending on what key was pressed. For letter keys pressed
by the player, we need to add them to the wordguess. For the
backspace key, we need to remove the last letter. Finally, for the
enter key, we need to handle the word entry. Below is the method
in App.tsx that handles our keypresses coming from the virtual
keyboard:

```

Part Five 62
1 **const** handleOnClickedKey=(key: **string** ): **void** =>{
2 **if** (key.toLowerCase()==='backspace') {
3 **if** (wordGuess.length!== 0 ) {
4 setWordGuess(wordGuess.substring( 0 ,
5 wordGuess.length- 1 ))
6 }
7 }
8 **elseif** (key.toLowerCase()==='enter'
9 &&wordGuess.length=== 5 ) {
10 handleGuessCompletion(wordGuess)
11 }
12 **else** {
13 **if** (wordGuess.length< 5 ) {
14 setWordGuess(wordGuess+key)
15 }
16
17 }
18 }
ThehandleOnClickedKeycallback method is called from the
Keyboard prop in the keyboard component child inside App.tsx
upon clicking any virtual key:
1 <VirtualKeyboard onClickedKey={handleOnClickedKey}/>

### Coloring the Keys based on Accuracy

```

We have given the virtual keyboard the ability to allow the user
to make their entries through the screen rather than the computer
keyboard, but we can give the virtual keyboard some additional
functionality to make it useful to the player. We can color the
rendered keyboard to indicate if the letter exists in the answer,
whether its a letter is in the correct position, or if a letter is in the
wrong position.

```

Part Five 63
So where do we begin architect this feature? Well first of all, we
need a way to get the current guesses to the VirtualKeyboard
Component. That way the VirtualKeyboard can evaluate those
guesses and create a map of letter keys to accuracy values to use for
each virtual key. In order to retrieve a list of guessed words, we need
to get them from the WordBoard component. To get the guessed
words from the WordBoard, we’ll need to feed the guesses from
the WordBoard through a callback in the App component (similarly
how we just fed onClickedKey from the VirtualKeyboard). Then
we’ll need to feed those guesses back down to the VirtualKeyboard
component.
First we’ll introduce a callback into our WordBoard properties so
we can propogate the evaluated board guesses back to the App
component. We’ll call the callbackwordGuessesCallback:
1 **interface** IWordBoardProps {
2 guess : **string**
3 currentPosition: **number** ,
4 wordGuessesCallback(guesses: **IGuess** []): **void**
5 }
6
7 **exportconst** WordBoard=(
8 { guess,
9 currentPosition,
10 wordGuessesCallback}:IWordBoardProps)=>{
11 }
Next we’ll call the callback with the evaluated guesses once the
WordBoard moves to the next position in the board:

Part Five 64
1 useEffect(()=>
2 {
3 _// pull out the evaluated guesses_
4 _// and send to the parent component_
5 wordGuessesCallback(
6 updatedGuesses.filter(guess=>guess.evaluated))
7 }
8 , [currentPosition])
In the parent App we can send in the callback function through the
wordGuessesCallback property
1 _// function to pass to the WordBoard to capture it's gues\_
2 ses
3 **const** handleWordGuesses=(guesses: **IGuess** [])=> {
4 setWordGuesses(guesses)
5 }
6
7
8 _// in App.tsx rendering, pass the callback\_
9 <WordBoard
10 guess={wordGuess}
11 currentPosition={nextGuessPosition}
12 wordGuessesCallback={handleWordGuesses}/>
Now that we’ve captured the word guesses from theWordBoard
component, we can pass the wordGuesses property down to theVir-
tualKeyboardto use in evaluating the color representing accuracy
on each key. We’ll add a new prop to the VirtualKeyboard called
wordGuessesto accomplish this.

Part Five 65
1 _// In App.tsx_
2 **return** (
3 <div className='App-board'>
4
5 _// retrieve word guesses through the callback_
6 <WordBoard
7 guess={wordGuess}
8 currentPosition={nextGuessPosition}
9 wordGuessesCallback={handleWordGuesses} />
10
11 _// pass word guesses into the VirtualKeyboard_
12 _// through the wordGuesses prop_
13 <VirtualKeyboard
14 onClickedKey={handleOnClickedKey}
15 wordGuesses={wordGuesses}/>
16 </div>
17 )
Now we are all set to use the existing evaluated word guesses inside
of our VirtualKeyboard component. In order to do this, we’ll create
a new evaluation function that goes through all the evaluated words
and all the letters in each of these words and creates a map of the
accuracy of all letters guessed so far:
First we we use theuseEffecthook in the VirtualKeyboard com-
ponent to call calculate the letter accuracy map everytime the
wordGuesses array changes. In other words, it will call useEffect,
everytime a new row has been entered by the player. This useEffect
will also set the map as a state in the keyboard which will force the
virtual keyboard to render with the color indication on the guessed
letters.

Part Five 66
1 _// inside of VirtualKeyboard_
2 useEffect(()=>{
3 **const** tempLetterScoreMap=
4 calculateLetterAccuracyMap(
5 wordGuesses
6 .filter(g=>g.evaluated)
7 .map((guess)=>
8 { **return** guess.guessedWord}))
9 setLetterScoreMap(tempLetterScoreMap)
10 }, [wordGuesses])
Below is the method called calculateLetterAccuracyMapthat
takes the list of evaluated word guesses and constructs a map
(accuracyMap) with letter as the key and accuracy score as the
value. Note that when we add keyvalues to the map, we need to
make sure we don’t overwrite a higher accuracy value with a lower
accuracy value. For example, in the case where we guess two of the
same letters in the word and only one of them is included, we don’t
want to overwrite the map with the letter whose accuracy is already
marked correct with the letter whose accuracy is does not exist.
1 **export const** calculateLetterAccuracyMap=(words: **string** \
2 []):
3 Map< **string** , AccuracyEnum>=>{
4
5 **const** accuracyMap= **new** Map< **string** , AccuracyEnum>()
6
7 _// loop through each guess and retrieve_
8 _// the accuracy score_
9 words.forEach(word=>{
10 **const** scoringResults=
11 evaluateWordScore(word,
12 retrieveAnswer().toUpperCase())
13
14 _// combine the result of letter and_

Part Five 67
15 _// accuracy into one array of letter_
16 _// score pairs_
17 **const** combinedResults: **ILetterScorePair** []=
18 scoringResults
19 .map((score, scoreIndex) =>
20 {
21 **return** {letter: **word** [scoreIndex],
22 accuracy: **score** }
23 })
24
25 _// add each key value pair into the accuracyMap_
26 combinedResults.map((result) =>
27 {
28 _// handle case where its already_
29 _// marked in the map from another_
30 _// letter, and mark by precedence_
31 _// of highest accuracy to lowest_
32 **if** (accuracyMap.has(result.letter)) {
33 **const** currentAccuracy =
34 accuracyMap.get(result.letter)
35 **if** (Number(currentAccuracy)>
36 Number(result.accuracy)) {
37 accuracyMap.set(result.letter,
38 result.accuracy)
39 }
40 }
41 **else** {
42 accuracyMap.set(result.letter,
43 result.accuracy)
44 }
45 })
46 })
47
48 **return** accuracyMap
49 }

Part Five 68
Now that we’ve calculated a map for all the guessed letters we can
use it to render the virtual key colors appropriately. We’ll add a
new function calledlookupLetterAccuracythat will lookup the
letter accuracy from theletterScoreMapwe just created in the
calculateLetterAccuracyMapfunction:
1 **const** lookupLetterAccuracy=(letter: **string** ):AccuracyE\
2 num=>{
3 **if** (letterScoreMap.has(letter)) {
4 **return** letterScoreMap.get(letter)
5 ??AccuracyEnum.none
6 }
7 **else** {
8 **return** AccuracyEnum.none
9 }
10 }
Now all we need to do, is alter the tsx code that renders the keys
based on accuracy to call the lookupLetterAccuracy function. For
example, the top row now has the following code which maps each
key in the top row to a letter and an accuracy:
1 <StyledKeyboardRow>
2 {firstRow.map(virtualkey=>{
3 **return** (
4 <VirtualKey
5 value={virtualkey}
6 accuracy={lookupLetterAccuracy(virtualkey\
7 )}
8 onClickedKey={onClickedKey}>
9 </VirtualKey>)})}
10 </StyledKeyboardRow>
When you put this all together, you get color indication on each
virtual key on the keyboard everytime you enter your guess.

Part Five 69
Adding the Keyboard Color Indication

### Conclusion

In this section, we showed you how to create a virtual keyboard
for the game which serves the purpose of both allowing the user to
enter their guess and also to indicate which guesses were already
made. We took advantage of styled-components to style the virtual
keys and leveraged props on the children to pass information back
and forth about the word guesses. We hoped you enjoyed this five
part series on using React to create a Wordle game. Please feel free
to download the fullsource code¹.
¹https://github.com/microgold/wordle

## Appendix

```

TypeScript concepts Needed for this book
TypeScript is a very powerful language for doing client-side web
development and has many features that improve coding over
Javascript and tend to make coding more concise as well. Although
we don’t take advantage of all of TypeScript’s feature set, we
probably want to go over some of the TypeScript concepts we use
with this React application.

```

### Union Types.

In Typescript, we can allow a value to take on different types with
union types:
1 **const** [winning, setWinning]=
2 useState< **boolean** | **null** >( **null** )
In the useState above, we allow the winning state to take on a value
of either type boolean (true or false) or of type null. We could not,
however, call setWinning with a value of number type.

### Interfaces

```

An interface can be used to define the strict typing of a Javascript
object. We use interfaces extensively in this project to add types
to props being fed into a component. We also use interfaces for
guesses. For example, we created a Wordle interface called IGuess

```

Appendix 71
to define a word guess. It holds the full definition of the guess we
are tracking that contains the guessWord of type string and the
evaluation flag of type boolean.
1 **interface** IGuess {
2 guessedWord: **string** ,
3 evaluated: **boolean**
4 }
We can use this interface to enforce a type on a particular guess or
collection of guesses. For example
1 **const** guess =‘hello’
2
3 **const** currentGuess: **IGuess** =
4 {
5 guessedWord: **guess** ,
6 evaluated: **false**
7 }
creates an object currentGuess with the string value ‘hello’ and the
evaluated value of false. The following would give an error, because
the evaluated field type in the definition of IGuess is not a string,
but a boolean:
1 **const** guess =‘hello’
2
3 **const** currentGuess: **IGuess** =
4 {guessedWord: **guess** ,
5 evaluated:'MyFalseValue'}
You can also define functions in an interface as shown in the

Appendix 72
1 IWordEntryProps **interface** below:
2 **interface** IWordEntryProps {
3 onGuessEntered(guess: **string** ): **void**
4 onGuessComplete(): **void**
5 }
When defining an object containing the IWordEntryProps interface,
the signature for onGuessEntered and OnGuessComplete must
match the signature in the object or the compilation of the app will
get a build error.
Arrow Functions
The javascript way of writing functions was always
1 **function** display(message: **string** ) {
2 console.log(message)
3 }
You can still write functions this way in TypeScript (after all,
TypeScript is a superset of Javascript),
but another way is to use arrow functions:
1 **const** display =(message: **string** )=>{
2 console.log(message);
3 }
You will see arrow functions throughout the React code, and these
days, it is the preferred way of writing functions in React.

### Named functions vs Anonymous Functions.

```

A named function is a function with a name, for example, in our
React code, replaceAt is a named function that replaces a string

```

Appendix 73
with another string at a certain position in the string. replaceAt is
the name of our named function. It takes a source string, an index,
and a replacement and it returns a string with the replaced value.
1 **const** replaceAt=(source: **string** , index: **number** ,
2 replacement: **string** ): **string** =>{
3 **if** (index >=source.length) {
4 **return** source.valueOf()
5 }
6
7 **return** source.substring( 0 , index)+
8 replacement+
9 source.substring(index+ 1 )
10 }
An anonymous function has no name. We use anonymous func-
tions all the time in our useEffect hooks:
1 useEffect(()=>{
2 **if** (currentWordIndex> 5 ) **return**
3 ...
4 setWordGuesses(updatedGuesses)
5 }, [guess])
The ())function in the hook is an anonymous function, as it has
no name.

### Deconstruction

```

Whenever we pass props into a ReactJS Component, it is good
practice to force those props to adhere to an interface. We also
want to make it easier on the programmer, so they don’t have to
reference each and every field on the interface from a prop object.

```

Appendix 74
This is where deconstruction comes in. Deconstruction allows us
to decompose all the fields of an interface into the interface’s
individual fields and function components.
When we pass props into a component without deconstruction in
Typescript, it looks something like the following:
1 **exportconst** WordBoard=(props: **IWordBoardProps** )=>{
In order to reference the props in our component, we would have
needed to use the guess prop as follows:
console.log(guess = ${props.guess}). In other words, we would
always need to refer to the props through the dereferencing as
props.field. This might look a little messy, having props everywhere
in the code.
Now let’s try using deconstruction. Below we deconstruct the
props coming into the WordBoard component as an object of type
IWordBoardProps, just as we did previously. We then deconstruct
the two fields on IWordBoardProps into the guess field and the
currentPosition field inside the curly brackets as.
1 **interface** IWordBoardProps {
2 guess : **string**
3 currentPosition: **number** ,
4 }
5
6
7 **exportconst** WordBoard=(
8 {guess, currentPosition}:IWordBoardProps)=>{
We can now reference the guess and currentPosition props individu-
ally, as if they were no longer part of the props object. For example:

Appendix 75
1 console.log(`guess = **${** guess **}** `)
This makes our component code look a lot cleaner.

### Enums

Enums (Enumerations) allow us to define a new type that can
take on certain allowed values defined in the enum. Below is our
AccuracyEnum created to define the accuracy of a letter guess in
Wordle.
1 **exportenum** AccuracyEnum {
2 correct,
3 wrongPosition,
4 doesNotExist,
5 none
6 }
To declare an enum, simply declare it like any other type and
assign it to one of the allowable values. The code below assigns
letterAccuracy to be a value of AccuracyEnum.none
const letterAccuracy : AccuracyEnum = AccuracyEnum.none

### Map Type

```

TypeScript Map is a new data structure introduced in ES6. The Map
allows us to associate a key with a value in a collection of key-
values. In our Wordle Application, we use the Map in order to map
accuracy states to letter colors. Below is the declaration to look up
color values from different accuracies from our wordle project

```

Appendix 76
1 **exportconst** accuracyColorMap=
2 **new** Map<AccuracyEnum, **string** >(
3 [
4 [AccuracyEnum.correct,'#6CA965'],
5 [AccuracyEnum.wrongPosition,'#C8B653'],
6 [AccuracyEnum.none,'black'],
7 [AccuracyEnum.doesNotExist,'#787C7F']
8 ]
9 )
The Map gives us several functions to make looking up map values
easier. In our case, we use the get function of the Map to retrieve the
color value from the accuracy key. We make this call inside a styled
component called StyleLetterButton in order to set the background
for the letter tile:
1 background: **$** {props=>
2 accuracyColorMap.get(props.accuracy)};

### map function

```

The map function is different from the Map type. In React we use
the map function all over the place for rendering a collection—it is
a common React pattern! What the map function does is allow us
to transform an array of elements into renderable tsx. Here is an
example of where we render all our word guesses into words on
the board:

```

Appendix 77
1 **return** (
2 <>
3 {
4 wordGuesses.map(
5 (wordGuess: **IGuess** , index: **number** )=>
6 {
7 **return** <Word
8 key={`guesses_ **${** index **}** `}
9 isWordEvaluated={wordGuess.evaluated}
10 guessWordValue={wordGuess.guessedWord\
11 }
12 />
13 })
14
15 }
16 </>
17 )
wordGuessesis a simple collection of strings, but the map function
projects that into words appearing on the Wordle board in the
browser. The map function takes an arrow function that can have
up to 2 parameters; the first parameter is the value of the item in the
collection. In the guess of wordGuesses, wordGuess (of type IGuess)
is the value. Optionally, the arrow function can also take an index.
The index is the position of the value in the array. We use both the
wordGuess value and wordGuess index as props in our rendering
of the Word component.

### Optional Chaining

```

Typescript supports optional chaining, which means if you chain
a set of functions or fields together, you can optionally call them
if they become null. On the code below, used in our game to set

```

Appendix 78
focus, we optionally get the current field on the ref and optionally
call focus if current is null or undefined
1 wordEntryRef?.current?.focus()
If we didn’t have the? before the dot operator, and if any of these
values were undefined, we would get an error at runtime.
```
````
