import { ArticleLayout } from "@/layouts/article-layout"

export const meta = {
  author: "Alex Vyber",
  date: "2023-02-01",
  title: "Typing Classes",
  description: "Typing Classes",
}

export default (props) => <ArticleLayout meta={meta} {...props} />

TypeScript can be seen as a programming language that erases to JavaScript. On top of JavaScript
code that exists and is valid, we add another layer of type information that disappears once the
compiler has run. We can distinguish between declarations that create types and elements that create
values. Types are only available in TypeScript. They add a new name to an existing type space, we
use them for tooling, and they disappear the moment we compile down to JavaScript.

Value-creating declarations still exist in JavaScript. Func- tions, variables stuff that remains
after compilation. Separating these two worlds helps greatly when working with TypeScript, as you
can strip away the type-creating declarations and still have proper JavaScript that almost looks the
same. There is one thing, though, that contributes to both the type-creating space and the
value-creating space: classes.

Since the ECMAScript 2015 standard, JavaScript features classes as an alternate syntactic form for
the constructor function and prototype pattern. Here’s a class in pure JavaS- cript that applies a
discount to one of our articles:

```TypeScript
class Discount {
  isPercentage
  amount
  constructor(isPercentage, amount) {
    this.isPercentage = isPercentage
    this.amount = amount
  }
  apply(article) {
    if (this.isPercentage) {
      article.price = article.price - article.price * this.amount
    } else {
      article.price = article.price - this.amount
    }
  }
}

// A discount that shaves off 10 EUR
const discount = new Discount(false, 10)
discount.apply({
  price: 39,
  vat: 0.2,
  title: "Form Design Patterns",
})

```

With a few little extra type annotations, we can have proper tooling and can make sure that we
construct correct objects:

```TypeScript
class Discount {
  isPercentage: boolean
  amount: number

  constructor(isPercentage: boolean, amount: number) {
    this.isPercentage = isPercentage
    this.amount = amount
  }

  apply(article: Article) {
    if (this.isPercentage) {
      article.price = article.price - article.price * this.amount
    } else {
      article.price = article.price - this.amount
    }
  }
}
```

The moment we create a class, it’s available in the type space as well:

```TypeScript
let discount: Discount = new Discount(true, 0.2)
```

With custom object types, we always describe the shape of an object and make sure that all values
passed as parame- ters or assigned to variables match that shape.

### Structural Typing with Classes

Since TypeScript is a structural type system, we are also more interested in the shape of the
objects that are created by a class, rather than the class itself. So what’s the shape of a
class-generated object?

Classes have two parts:

1. The constructor function. We defined our construc- tor function to take a Boolean isPercentage,
   and a number for the amount we want to shave off. The moment we call new Discount(true, 0.2), we
   invoke the constructor function.
2. The second part is a prototype. This is everything around the constructor function: two fields
   (isPercentage, amount) and a function to apply the discount to an article.

The prototype defines the shape of the object that is re- turned by invoking the constructor. Now
that we know the shape, we can even assign regularly generated objects to a variable of type
`Discount`.

```TypeScript
let allProductsTwentyBucks: Discount = {
  isPercentage: false,
  amount: 20,

  apply(article) {
    article.price = 20
  },
}

```

This is a valid Discount, as the shape is intact. But it chang- es the semantics of the Discount
class tremendously. This also works vice versa. We can define an object type, and create a new
Discount object via a constructor:

```TypeScript
type DiscountType = {
  isPercentage: boolean
  amount: number

  apply(article: Article): void
}

let disco: DiscountType = new Discount(true, 0.2)
```

In a structural type system, only the shape is important. Names are sound and smoke.

### Extending Classes

One main feature of classes is that they are extensible. You can take an existing class and extend
it, overriding and adding features.

```TypeScript
/**
 * This class always gives 20 %, but only if
 * the price is not higher than 40 EUR
 */
class TwentyPercentDiscount extends Discount {
  // No special constructor
  constructor() {
    // But we call the super constructor of
    // Discount
    super(true, 0.2)
  }

  apply(article: Article) {
    if (article.price <= 40) {
      super.apply(article)
    }
  }
}
```

We created a discount class that always applies 20%, but only if the article’s price is lower than
40 Euro. In this special case, TwentyPercentDiscount is of the same shape as Discount, which means
that their type declaration is interchangeable:

```TypeScript
let disco1: Discount = new TwentyPercentDiscount() // OK
let disco2: TwentyPercentDiscount = new Discount(true, 0.3) // OK! Semantics changed!
```

But we can change the shape. Let’s create a validation fea- ture to TwentyPercentDiscount:

```TypeScript
class TwentyPercentDiscount extends Discount {
  constructor() {
    super(true, 0.2)
  }

  apply(article: Article) {
    if (this.isValidForDiscount(article)) {
      super.apply(article)
    }
  }

  isValidForDiscount(article: Article) {
    return article.price <= 40
  }
}
```

The shape has changed, which means that the same rules as for object types apply: if more properties
are available, the shape contract is satisfied; if properties are missing, the shape contract is not
fulfilled:

```TypeScript
let disco1: Discount = new TwentyPercentDiscount() // Still OK!
// Error! We miss the `isValidForDiscount` method
let disco2: TwentyPercentDiscount = new Discount(true, 0.3)
```

By now, classes have become a mainstay in JavaScript, especially since component-based frameworks
rely heavily on classes to define components. Typing classes might be a little bit confusing, as it
merges the two worlds of type creation and value creation, but as long as we keep the main
principles of a structural type system in mind, they’re as easy to use.

And they’d better be. Classes were one of TypeScript’s first killer features that brought people
from the C# and Java worlds to JavaScript. TypeScript featured one of the first ECMAScript class
implementations as the first proof of con- cept that classes could work in JavaScript. The syntax
hasn’t changed much since then.
